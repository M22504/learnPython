{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Python Coding Workshop! The Curriculum This Coding Workshop covers the fundamentals of the Python Programming Language, and is ideally taught over 3 Days with 2 Hours of Lessons per day. The topics are as follows: S/N Topic Sub-Topic 1 Intro to Python and IDLE Using print and input functions Accessing IDLE 2 Operations Basic Arithmetic ( + , - , * , / , // , % , ** ) Order and Operations (BODMAS/PEMDAS) 3 Variables & Assignment Box Analogy Assignment Statements ( = , += , -= , *= , /= \u2026) 4 Types int , float , bool , str , None Type Casting 5 Conditionals if Statement else Statement elif Statement and Control Flow 6 Loops for Loop while Loop 7 Functions Defining Functions return Statement and lambda Functions Functions as Objects (e.g. map , filter , etc.) 8 Arrays / Lists Storage, Append and Remove Indexing (and String Indexing) 9 External Libraries math Library random Library 10 Exceptions and Error Handling Exceptions try , except , else and finally Statements 11 External Systems Accessing the Command Line pip PyPI and numpy Docs (+ Debugger) Session Details Our sessions will take place from 16th to 18th March on Zoom or Teams. The current curriculum plan is as follows: Day Date Duration Topics Covered Day 1 16th March 2 Hours Topics 1 - 4 Day 2 17th March 2 Hours Topics 5 - 8 Day 3 18th March 2 Hours Topics 9 - 11 We have yet to trial run this curriculum, so we will require a lot more time to confirm this schedule. Lesson Plan Lesson 1 In lesson 1, we will be covering the following topics: 1. Intro to Python and IDLE (Expected Time: 15 minutes) 2. Operations (Expected Time: 15 minutes) 3. Variables and Assignments (Expected Time: 30 minutes) 4. Types (Expected Time: 50 minutes) Activities in Chapter 1 Lesson 2 Conditionals (Expected Time: 25 minutes) Functions (Expected Time: 30 minutes) Loops (Expected Time: 20 minutes) Arrays and Lists (Expected Time: 25 minutes) Lesson 3 Modules and Packages (Expected Time: 30 minutes) Exceptions (Expected Time: 25 minutes) External Systems - Going Forward (Expected Time: 55 minutes)","title":"Home"},{"location":"#the-curriculum","text":"This Coding Workshop covers the fundamentals of the Python Programming Language, and is ideally taught over 3 Days with 2 Hours of Lessons per day. The topics are as follows: S/N Topic Sub-Topic 1 Intro to Python and IDLE Using print and input functions Accessing IDLE 2 Operations Basic Arithmetic ( + , - , * , / , // , % , ** ) Order and Operations (BODMAS/PEMDAS) 3 Variables & Assignment Box Analogy Assignment Statements ( = , += , -= , *= , /= \u2026) 4 Types int , float , bool , str , None Type Casting 5 Conditionals if Statement else Statement elif Statement and Control Flow 6 Loops for Loop while Loop 7 Functions Defining Functions return Statement and lambda Functions Functions as Objects (e.g. map , filter , etc.) 8 Arrays / Lists Storage, Append and Remove Indexing (and String Indexing) 9 External Libraries math Library random Library 10 Exceptions and Error Handling Exceptions try , except , else and finally Statements 11 External Systems Accessing the Command Line pip PyPI and numpy Docs (+ Debugger)","title":"The Curriculum"},{"location":"#session-details","text":"Our sessions will take place from 16th to 18th March on Zoom or Teams. The current curriculum plan is as follows: Day Date Duration Topics Covered Day 1 16th March 2 Hours Topics 1 - 4 Day 2 17th March 2 Hours Topics 5 - 8 Day 3 18th March 2 Hours Topics 9 - 11 We have yet to trial run this curriculum, so we will require a lot more time to confirm this schedule.","title":"Session Details"},{"location":"#lesson-plan","text":"","title":"Lesson Plan"},{"location":"#lesson-1","text":"In lesson 1, we will be covering the following topics: 1. Intro to Python and IDLE (Expected Time: 15 minutes) 2. Operations (Expected Time: 15 minutes) 3. Variables and Assignments (Expected Time: 30 minutes) 4. Types (Expected Time: 50 minutes)","title":"Lesson 1"},{"location":"#activities-in-chapter-1","text":"","title":"Activities in Chapter 1"},{"location":"#lesson-2","text":"Conditionals (Expected Time: 25 minutes) Functions (Expected Time: 30 minutes) Loops (Expected Time: 20 minutes) Arrays and Lists (Expected Time: 25 minutes)","title":"Lesson 2"},{"location":"#lesson-3","text":"Modules and Packages (Expected Time: 30 minutes) Exceptions (Expected Time: 25 minutes) External Systems - Going Forward (Expected Time: 55 minutes)","title":"Lesson 3"},{"location":"Chapter-0-%28Installation%29/","text":"Hello, students. In this \"lesson\", I'll be teaching you how to install Python and IDLE, which are two very important systems used for Computer Science and Programming in general. Installing Python Python's installation is quite simplistic. Follow the following steps: Go to https://www.python.org/ and click on the Downloads page as indicated below: Scroll down to \"Looking for a specific release?\" and locate version 3.8.7 . Click on the Download button as shown below: Scroll down and choose the preferable version based on your computer's Operating System as shown below: Open the installed file, which launches the following wizard. Make sure to click \"Add Python 3.8 to PATH\" as shown and confirm installation: Now, wait for the installation. You should see the following screen for a long while, and wait till the entire bar is green: Once the installation is complete, you should see the following screen. For now, you can ignore the \"Disable path limit\" warning. Simply go ahead and close the wizard as shown: And there, you've installed Python! Wait, not so fast. Your Python Version may not have been installed properly. If you run into any major problems, you can raise any questions you may have by emailing us.","title":"Chapter 0 (Installation)"},{"location":"Chapter-0-%28Installation%29/#installing-python","text":"Python's installation is quite simplistic. Follow the following steps: Go to https://www.python.org/ and click on the Downloads page as indicated below: Scroll down to \"Looking for a specific release?\" and locate version 3.8.7 . Click on the Download button as shown below: Scroll down and choose the preferable version based on your computer's Operating System as shown below: Open the installed file, which launches the following wizard. Make sure to click \"Add Python 3.8 to PATH\" as shown and confirm installation: Now, wait for the installation. You should see the following screen for a long while, and wait till the entire bar is green: Once the installation is complete, you should see the following screen. For now, you can ignore the \"Disable path limit\" warning. Simply go ahead and close the wizard as shown: And there, you've installed Python! Wait, not so fast. Your Python Version may not have been installed properly. If you run into any major problems, you can raise any questions you may have by emailing us.","title":"Installing Python"},{"location":"Chapter-1-%28Intro-To-Python-and-IDLE%29/","text":"Agenda Using print and input functions Accessing IDLE A Brief Introduction to Python Python was introduced back in the 1980s, then still a relative unknown language that surged in popularity in the recent years due to it's easy-to-use syntax, readable code, access to powerful libraries and many more. Python is a language known for its versatility in programming paradigms and simply being quite easy to use. In fact, Python scored a perfect score on the IEEE Spectrum Ranking for the Top Programming Languages . It is well-applied in domains such as Web Development (with frameworks like Django , Flask and CherryPy ), Scientific Computing and Data Science (with libraries such as NumPy , SciPy , Matplotlib , Pandas and SymPy ) and Artificial Intelligence and Machine/Deep Learning (with frameworks like scikit-learn , TensorFlow , Keras , PyTorch and Caffe ). Introducing IDLE IDLE is an application developed by the Python Software Foundation. This app is one of the most useful Python essentials, since it works as a code editor and incorporates the Python Shell, which is one of the most important tools you will use in Python. In our experience, you can do most of your coding for this module on IDLE, but if you're more experienced, you can also use Microsoft's Visual Studio 2019 or Visual Studio Code or JetBrains' PyCharm IDE. You can also access the Python Shell from the Terminal (Command Prompt on Windows), although Terminal may not be the easiest to use in general, hence we suggest using IDLE. Alright, so, how to you use IDLE?","title":"Chapter 1 (Intro To Python and IDLE)"},{"location":"Chapter-1-%28Intro-To-Python-and-IDLE%29/#agenda","text":"Using print and input functions Accessing IDLE","title":"Agenda"},{"location":"Chapter-1-%28Intro-To-Python-and-IDLE%29/#a-brief-introduction-to-python","text":"Python was introduced back in the 1980s, then still a relative unknown language that surged in popularity in the recent years due to it's easy-to-use syntax, readable code, access to powerful libraries and many more. Python is a language known for its versatility in programming paradigms and simply being quite easy to use. In fact, Python scored a perfect score on the IEEE Spectrum Ranking for the Top Programming Languages . It is well-applied in domains such as Web Development (with frameworks like Django , Flask and CherryPy ), Scientific Computing and Data Science (with libraries such as NumPy , SciPy , Matplotlib , Pandas and SymPy ) and Artificial Intelligence and Machine/Deep Learning (with frameworks like scikit-learn , TensorFlow , Keras , PyTorch and Caffe ).","title":"A Brief Introduction to Python"},{"location":"Chapter-1-%28Intro-To-Python-and-IDLE%29/#introducing-idle","text":"IDLE is an application developed by the Python Software Foundation. This app is one of the most useful Python essentials, since it works as a code editor and incorporates the Python Shell, which is one of the most important tools you will use in Python. In our experience, you can do most of your coding for this module on IDLE, but if you're more experienced, you can also use Microsoft's Visual Studio 2019 or Visual Studio Code or JetBrains' PyCharm IDE. You can also access the Python Shell from the Terminal (Command Prompt on Windows), although Terminal may not be the easiest to use in general, hence we suggest using IDLE. Alright, so, how to you use IDLE?","title":"Introducing IDLE"},{"location":"Chapter-10-%28Exceptions%29/","text":"What are Exceptions? Through the past nine chapters, you likely have encountered cases where you code abruptly terminates because something went wrong. A logical error that causes this is termed as an exception, and generally there are a few types that are common. When an exception occurs, we call it throwing an exception. Generally, exceptions have the following format when they are thrown: Traceback ( most recent call last ): File \"(filename)\" , line X , in < module > ( the line that caused the exception ) ( exception name ): ( exception description ) If you attempt to reproduce the example exceptions in the shell to get an understanding of how they work, do not worry if the first three lines do not match: The last line of the exception is the most important for understanding what exactly went wrong. SyntaxErrors You may have encountered SyntaxErrors as you went through the previous chapters. If you did encounter one, you would notice that it doesn't match the format of a thrown exception described above: that would be because SyntaxErrors are not exceptions at all. Unlike exceptions, which are thrown when logic in the program does not add up, SyntaxErrors are thrown because the code itself does not make sense -- it is incomprehensible to the computer. This usually occurs due to typos, and these must be fixed before the program runs at all. Some examples of SyntaxErrors are shown below: >>> def a () SyntaxError : expected ':' >>> print ( \"Hello World\" ] SyntaxError : closing parenthesis ']' does not match opening parenthesis '(' >>> def a (): print ( \"a\" ) print ( \"b\" ) SyntaxError : unexpected indent Types of Exceptions There are many kinds of exceptions in Python. Here, we will be going through the types that are more commonly run into. NameError NameErrors occur when a term that is used, whether a variable or function, is not defined when it is trying to be used. This can arise from a few reasons. The easiest to resolve is simply that you misspelled the name of the variable, as in the example below: >>> var1 = 5 >>> vat1 Traceback ( most recent call last ): File \"<pyshell#27>\" , line 1 , in < module > vat1 NameError : name 'vat1' is not defined . Did you mean : 'var1' ? Python is generally kind enough to try and catch typos for you, as shown above. If this is not the case, then you should check your variable scope -- perhaps you are trying to reference a local variable from a global context, such as in the following case. If you encounter such an issue, consider returning the value that you have defined within the function scope to access it in the global scope, if it is required. >>> def a(): b = 5 return b >>> b Traceback (most recent call last): File \"<pyshell#25>\", line 1, in <module> b NameError: name 'b' is not defined TypeError TypeErrors result when something is attempted but the input is of the wrong type, for example as shown below: >>> \"1\" + 1 Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > \"1\" + 1 TypeError : can only concatenate str ( not \"int\" ) to str The solution to TypeErrors is generally to use typecasting, if the operation is intentional. >>> int ( \"1\" ) + 1 2 ValueError ValueErrors, meanwhile, occur if the input is of the correct type, but uses an unsupported value for the operation. For example, typecasting a string that does not contain an integer to int: >>> int ( \"a\" ) Traceback ( most recent call last ): File \"<pyshell#0>\" , line 1 , in < module > int ( \"a\" ) ValueError : invalid literal for int () with base 10 : 'a' >>> int ( \"2.0\" ) Traceback ( most recent call last ): File \"<pyshell#5>\" , line 1 , in < module > int ( \"2.0\" ) ValueError : invalid literal for int () with base 10 : '2.0' Another example would be trying to take the square root of a negative number. >>> import math >>> math . sqrt ( - 1 ) Traceback ( most recent call last ): File \"<pyshell#7>\" , line 1 , in < module > math . sqrt ( - 1 ) ValueError : math domain error IndexError IndexErrors occur when an invalid index is used. This occurs when dealing with strings or lists, such as below: >>> str1 = \"abc\" >>> str1 [ 3 ] Traceback ( most recent call last ): File \"<pyshell#14>\" , line 1 , in < module > str1 [ 3 ] IndexError : string index out of range >>> list1 = [ 1 , 2 , 3 ] >>> list1 [ 3 ] Traceback ( most recent call last ): File \"<pyshell#14>\" , line 1 , in < module > list1 [ 3 ] IndexError : list index out of range This commonly occurs in an \"off-by-one error\", where loops iterate one more time than they should, causing the attempted access of an entry one past the last location. It can also be a result of one-indexing the positions instead of zero-indexing as the language does. An example of an off-by-one error is in the following snippet: >>> list2 = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> list3 = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> for i in range ( 7 ): print ( list2 [ i ] + list3 [ i ]) 2 4 6 8 10 12 Traceback ( most recent call last ): File \"<pyshell#19>\" , line 2 , in < module > print ( list2 [ i ] + list3 [ i ]) IndexError : list index out of range Remember that the range() function is inclusive of the lower bound and exclusive of the upper bound! For safety, if you want to iterate as many times as the list has entries, the usage of range(len(list)) is recommended. RuntimeError RuntimeErrors are generic errors -- they are caused when the exception does not fall into any of the defined categories. A string will be displayed that describes the error. ZeroDivisionError ZeroDivisionErrors, as the name suggests, occur when there is an attempted division by zero. >>> 1 / 0 Traceback ( most recent call last ): File \"<pyshell#20>\" , line 1 , in < module > 1 / 0 ZeroDivisionError : division by zero Exception Handling with try-except-else-finally Python, like most programming languages, has an in-built way of catching thrown exceptions and handling them within the code. This allows for the program to gracefully handle the error, instead of unceremoniously terminating. DISCLAIMER: Do NOT use this as a way to bypass exceptions! Most exceptions that are thrown can be avoided simply by modifying the code to not throw them. Using try-except to bypass such exceptions is bad style that will slow down execution. Instead, try-except should only be used to catch errors that cannot be predicted, such as errors from user input. The syntax and program flow of try-except-else-finally The syntax of exception handling contains up to four blocks. In the following section, we will slowly add the blocks, starting from the most fundamental components and slowly adding the remaining two. try-except The most basic form of exception handling uses try-except.","title":"What are Exceptions?"},{"location":"Chapter-10-%28Exceptions%29/#what-are-exceptions","text":"Through the past nine chapters, you likely have encountered cases where you code abruptly terminates because something went wrong. A logical error that causes this is termed as an exception, and generally there are a few types that are common. When an exception occurs, we call it throwing an exception. Generally, exceptions have the following format when they are thrown: Traceback ( most recent call last ): File \"(filename)\" , line X , in < module > ( the line that caused the exception ) ( exception name ): ( exception description ) If you attempt to reproduce the example exceptions in the shell to get an understanding of how they work, do not worry if the first three lines do not match: The last line of the exception is the most important for understanding what exactly went wrong.","title":"What are Exceptions?"},{"location":"Chapter-10-%28Exceptions%29/#syntaxerrors","text":"You may have encountered SyntaxErrors as you went through the previous chapters. If you did encounter one, you would notice that it doesn't match the format of a thrown exception described above: that would be because SyntaxErrors are not exceptions at all. Unlike exceptions, which are thrown when logic in the program does not add up, SyntaxErrors are thrown because the code itself does not make sense -- it is incomprehensible to the computer. This usually occurs due to typos, and these must be fixed before the program runs at all. Some examples of SyntaxErrors are shown below: >>> def a () SyntaxError : expected ':' >>> print ( \"Hello World\" ] SyntaxError : closing parenthesis ']' does not match opening parenthesis '(' >>> def a (): print ( \"a\" ) print ( \"b\" ) SyntaxError : unexpected indent","title":"SyntaxErrors"},{"location":"Chapter-10-%28Exceptions%29/#types-of-exceptions","text":"There are many kinds of exceptions in Python. Here, we will be going through the types that are more commonly run into.","title":"Types of Exceptions"},{"location":"Chapter-10-%28Exceptions%29/#nameerror","text":"NameErrors occur when a term that is used, whether a variable or function, is not defined when it is trying to be used. This can arise from a few reasons. The easiest to resolve is simply that you misspelled the name of the variable, as in the example below: >>> var1 = 5 >>> vat1 Traceback ( most recent call last ): File \"<pyshell#27>\" , line 1 , in < module > vat1 NameError : name 'vat1' is not defined . Did you mean : 'var1' ? Python is generally kind enough to try and catch typos for you, as shown above. If this is not the case, then you should check your variable scope -- perhaps you are trying to reference a local variable from a global context, such as in the following case. If you encounter such an issue, consider returning the value that you have defined within the function scope to access it in the global scope, if it is required. >>> def a(): b = 5 return b >>> b Traceback (most recent call last): File \"<pyshell#25>\", line 1, in <module> b NameError: name 'b' is not defined","title":"NameError"},{"location":"Chapter-10-%28Exceptions%29/#typeerror","text":"TypeErrors result when something is attempted but the input is of the wrong type, for example as shown below: >>> \"1\" + 1 Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > \"1\" + 1 TypeError : can only concatenate str ( not \"int\" ) to str The solution to TypeErrors is generally to use typecasting, if the operation is intentional. >>> int ( \"1\" ) + 1 2","title":"TypeError"},{"location":"Chapter-10-%28Exceptions%29/#valueerror","text":"ValueErrors, meanwhile, occur if the input is of the correct type, but uses an unsupported value for the operation. For example, typecasting a string that does not contain an integer to int: >>> int ( \"a\" ) Traceback ( most recent call last ): File \"<pyshell#0>\" , line 1 , in < module > int ( \"a\" ) ValueError : invalid literal for int () with base 10 : 'a' >>> int ( \"2.0\" ) Traceback ( most recent call last ): File \"<pyshell#5>\" , line 1 , in < module > int ( \"2.0\" ) ValueError : invalid literal for int () with base 10 : '2.0' Another example would be trying to take the square root of a negative number. >>> import math >>> math . sqrt ( - 1 ) Traceback ( most recent call last ): File \"<pyshell#7>\" , line 1 , in < module > math . sqrt ( - 1 ) ValueError : math domain error","title":"ValueError"},{"location":"Chapter-10-%28Exceptions%29/#indexerror","text":"IndexErrors occur when an invalid index is used. This occurs when dealing with strings or lists, such as below: >>> str1 = \"abc\" >>> str1 [ 3 ] Traceback ( most recent call last ): File \"<pyshell#14>\" , line 1 , in < module > str1 [ 3 ] IndexError : string index out of range >>> list1 = [ 1 , 2 , 3 ] >>> list1 [ 3 ] Traceback ( most recent call last ): File \"<pyshell#14>\" , line 1 , in < module > list1 [ 3 ] IndexError : list index out of range This commonly occurs in an \"off-by-one error\", where loops iterate one more time than they should, causing the attempted access of an entry one past the last location. It can also be a result of one-indexing the positions instead of zero-indexing as the language does. An example of an off-by-one error is in the following snippet: >>> list2 = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> list3 = [ 1 , 2 , 3 , 4 , 5 , 6 ] >>> for i in range ( 7 ): print ( list2 [ i ] + list3 [ i ]) 2 4 6 8 10 12 Traceback ( most recent call last ): File \"<pyshell#19>\" , line 2 , in < module > print ( list2 [ i ] + list3 [ i ]) IndexError : list index out of range Remember that the range() function is inclusive of the lower bound and exclusive of the upper bound! For safety, if you want to iterate as many times as the list has entries, the usage of range(len(list)) is recommended.","title":"IndexError"},{"location":"Chapter-10-%28Exceptions%29/#runtimeerror","text":"RuntimeErrors are generic errors -- they are caused when the exception does not fall into any of the defined categories. A string will be displayed that describes the error.","title":"RuntimeError"},{"location":"Chapter-10-%28Exceptions%29/#zerodivisionerror","text":"ZeroDivisionErrors, as the name suggests, occur when there is an attempted division by zero. >>> 1 / 0 Traceback ( most recent call last ): File \"<pyshell#20>\" , line 1 , in < module > 1 / 0 ZeroDivisionError : division by zero","title":"ZeroDivisionError"},{"location":"Chapter-10-%28Exceptions%29/#exception-handling-with-try-except-else-finally","text":"Python, like most programming languages, has an in-built way of catching thrown exceptions and handling them within the code. This allows for the program to gracefully handle the error, instead of unceremoniously terminating. DISCLAIMER: Do NOT use this as a way to bypass exceptions! Most exceptions that are thrown can be avoided simply by modifying the code to not throw them. Using try-except to bypass such exceptions is bad style that will slow down execution. Instead, try-except should only be used to catch errors that cannot be predicted, such as errors from user input.","title":"Exception Handling with try-except-else-finally"},{"location":"Chapter-10-%28Exceptions%29/#the-syntax-and-program-flow-of-try-except-else-finally","text":"The syntax of exception handling contains up to four blocks. In the following section, we will slowly add the blocks, starting from the most fundamental components and slowly adding the remaining two.","title":"The syntax and program flow of try-except-else-finally"},{"location":"Chapter-10-%28Exceptions%29/#try-except","text":"The most basic form of exception handling uses try-except.","title":"try-except"},{"location":"Chapter-2-%28Operations%29/","text":"Some Math Coding requires math, and that calls for some arithmetic operators . Operator Function Example + Addition >>> 1 + 1 2 - Subtraction >>> 2 - 3 -1 * Multiplication >>> 5 * 7 35 / Division >>> 9 / 6 1.5 // Floor division >>> 9 // 6 1 % Modulus >>> 9 % 6 3 ** Exponentiation >>> 5 ** 2 25 Remember never to use ^ for exponents! It is a bitwise operator with a totally different function. It may not always throw an error, which means that you may unknowingly end up with a wrong output! Seems simple enough? Yes! But wait... what is floor division and modulus? Division, but not quite 9 \u00f7 6 = 1 R 3 Floor division: 9 // 6 = 1 Modulus: 9 % 6 = 3 (This is read as 9 modulo/mod 6 equals 3.) Nowww it makes sense. Floor division returns the quotient , while modulus returns the remainder . But what happens if you have multiple operations in one line? BODMAS, or PEMDAS BODMAS/PEMDAS represents the order of mathematical operations, which is exactly the same as in math. In descending order of priority, we have: B/P: Brackets/Parentheses ( () ) O/E: Orders/Exponents ( ** ) D & M: Division & Multiplication ( / , // , % , * ) A & S: Addition & Subtraction ( + , - ) All of this is the same as in math! For example... >>> 3 * 5 ** 2 75 >>> ( 3 * 5 ) ** 2 225 >>> 3 + 4 - 2 ** 3 - 1 Simple enough? Try out some trickier exercises, and check your answers by typing them out in IDLE. >>> 25 // 6 - 4 // 2 * 3 / 2 >>> 123 // 4 ** 2 - 3 / 2 ** ( 4 * 7 - 30 ) And that's it! Remember your arithmetic operators and their orders, and you're set for most of the math that you will encounter when coding with Python.","title":"Chapter 2 (Operations)"},{"location":"Chapter-2-%28Operations%29/#some-math","text":"Coding requires math, and that calls for some arithmetic operators . Operator Function Example + Addition >>> 1 + 1 2 - Subtraction >>> 2 - 3 -1 * Multiplication >>> 5 * 7 35 / Division >>> 9 / 6 1.5 // Floor division >>> 9 // 6 1 % Modulus >>> 9 % 6 3 ** Exponentiation >>> 5 ** 2 25 Remember never to use ^ for exponents! It is a bitwise operator with a totally different function. It may not always throw an error, which means that you may unknowingly end up with a wrong output! Seems simple enough? Yes! But wait... what is floor division and modulus?","title":"Some Math"},{"location":"Chapter-2-%28Operations%29/#division-but-not-quite","text":"9 \u00f7 6 = 1 R 3 Floor division: 9 // 6 = 1 Modulus: 9 % 6 = 3 (This is read as 9 modulo/mod 6 equals 3.) Nowww it makes sense. Floor division returns the quotient , while modulus returns the remainder . But what happens if you have multiple operations in one line?","title":"Division, but not quite"},{"location":"Chapter-2-%28Operations%29/#bodmas-or-pemdas","text":"BODMAS/PEMDAS represents the order of mathematical operations, which is exactly the same as in math. In descending order of priority, we have: B/P: Brackets/Parentheses ( () ) O/E: Orders/Exponents ( ** ) D & M: Division & Multiplication ( / , // , % , * ) A & S: Addition & Subtraction ( + , - ) All of this is the same as in math! For example... >>> 3 * 5 ** 2 75 >>> ( 3 * 5 ) ** 2 225 >>> 3 + 4 - 2 ** 3 - 1 Simple enough? Try out some trickier exercises, and check your answers by typing them out in IDLE. >>> 25 // 6 - 4 // 2 * 3 / 2 >>> 123 // 4 ** 2 - 3 / 2 ** ( 4 * 7 - 30 ) And that's it! Remember your arithmetic operators and their orders, and you're set for most of the math that you will encounter when coding with Python.","title":"BODMAS, or PEMDAS"},{"location":"Chapter-3-%28Variables-and-Assignments%29/","text":"Let's go back to maths. In algebra, x is used as a representation of a number. If I let x = 33241, it follows that 3 x = 99723, x + 1 = 33242, without me needing to write the original number again. Since the value of x can vary, we call it a variable . Most languages (including Python) have variables at their core. In Python, you can imagine the variable as a labelled box storing a value. You can replace the value in the box at any time. For the example of x = 3, you can visualize it like so: Variables consist of two important parts: the name and the value. Variable Name Unlike in maths: * Variable names must be unique (there are minor exceptions) * Variable names can be more than a letter. \"score\", \"camel_1\" and \"x\" are all valid variable names * Variable names CANNOT start with a number or symbol. \"123_o\" and \"$\" are not allowed * Variable names CANNOT be special names used in Python. For example, since print() is a Python function, \"print\" is not a valid name. However, \"print_1\" and other names that do not match exactly are allowed * Variables are case sensitive. That is, \"variable_x\" is different from \"Variable_x\" which is in turn also different from \"variable_X\". Conventionally, * Variables are written with short, meaningful names * Variables are named with lowercase letters, using underscores in place of spaces Variable Value Unlike in maths: * Variables need not represent numbers. You can store other things in variables, like letters/words (known as strings) (Chapter 4), functions (Chapter 7), or lists (Chapter 8) To define a variable with name \"var_1\" and value of 2.5, var_1 = 2.5 This is called variable assignment , since we are assigning a value to a variable. The equals sign is know as an assignment operator . It is an operator, just like the mathematical operators in Chapter 2. Now, we can check the value of the variables var_1: print ( var_1 ) 2.5 We can reassign the value of var_1 to an integer: var_1 = 5 print ( var_1 ) 5 We can also define a variable using an existing variable: var_2 = var_1 print ( var_2 ) 5 var_3 = var_1 * var_2 + 10 print ( var_3 ) 35 We can even change a variable using itself: var_1 = 12 - var_1 print ( var_1 ) 7 There are other assignment operators which act as shortcuts for these cases: Statement Equivalent Statement (using Assignment Operators) var = var + 1 var += 1 var = var - 1 var -= 1 var = var * 10 var *= 10 var = var / 15 var /= 15 var = var % 2 var %= 2","title":"Chapter 3 (Variables and Assignments)"},{"location":"Chapter-3-%28Variables-and-Assignments%29/#variable-name","text":"Unlike in maths: * Variable names must be unique (there are minor exceptions) * Variable names can be more than a letter. \"score\", \"camel_1\" and \"x\" are all valid variable names * Variable names CANNOT start with a number or symbol. \"123_o\" and \"$\" are not allowed * Variable names CANNOT be special names used in Python. For example, since print() is a Python function, \"print\" is not a valid name. However, \"print_1\" and other names that do not match exactly are allowed * Variables are case sensitive. That is, \"variable_x\" is different from \"Variable_x\" which is in turn also different from \"variable_X\". Conventionally, * Variables are written with short, meaningful names * Variables are named with lowercase letters, using underscores in place of spaces","title":"Variable Name"},{"location":"Chapter-3-%28Variables-and-Assignments%29/#variable-value","text":"Unlike in maths: * Variables need not represent numbers. You can store other things in variables, like letters/words (known as strings) (Chapter 4), functions (Chapter 7), or lists (Chapter 8) To define a variable with name \"var_1\" and value of 2.5, var_1 = 2.5 This is called variable assignment , since we are assigning a value to a variable. The equals sign is know as an assignment operator . It is an operator, just like the mathematical operators in Chapter 2. Now, we can check the value of the variables var_1: print ( var_1 ) 2.5 We can reassign the value of var_1 to an integer: var_1 = 5 print ( var_1 ) 5 We can also define a variable using an existing variable: var_2 = var_1 print ( var_2 ) 5 var_3 = var_1 * var_2 + 10 print ( var_3 ) 35 We can even change a variable using itself: var_1 = 12 - var_1 print ( var_1 ) 7 There are other assignment operators which act as shortcuts for these cases: Statement Equivalent Statement (using Assignment Operators) var = var + 1 var += 1 var = var - 1 var -= 1 var = var * 10 var *= 10 var = var / 15 var /= 15 var = var % 2 var %= 2","title":"Variable Value"},{"location":"Chapter-4-%28Types%29/","text":"The types of Types Type Name Description Example int Integer Whole numbers 1 , -4 float Floating point Numbers with a decimal point 0.202 , 1.0 bool Boolean A logical value of either True or False only True , False str String An ordered sequence of characters \"Hello!\" , \"\u03b8\u03bf\u03b8\" , \"312\" NoneType None, or null A null value, which is different from 0 , \"\" , or False None ...and many more... But these four types are the most common ones that you will meet. Python is a dynamically typed (or untyped) language (as opposed to statically typed ones), which means that variables do not have a pre-set type, and can change types throughout the code. This also means that the coder does not need to define the type upon instantiating it. In other words, something like int a = 1 is not just unnecessary in Python; it throws an error! >>> a = 1 >>> type ( a ) < class ' int '> >>> a = True >>> type ( a ) < class ' bool '> int and float These types should be quite familiar as you have seen them in earlier sections. >>> a = 1 >>> type ( a ) < class ' int '> >>> a += 0.1 >>> a 1.1 >>> type ( a ) < class ' float '> In the above example, you can see that when variables are instantiated as whole numbers, their assigned type is int . However, once operations (e.g. addition, multiplication) with variables of type float are performed on them, the original variable becomes a float too. However, do note that all divisions result in a float output. >>> type ( 4 / 2 ) < class ' float '> bool This section should be the most logical. The only possible bool values are True and False ! Note that True and False must be capitalised! There are still some things to introduce, though, and these are the boolean operators and , or , and not . a b a and b a or b True True True True True False False True False True False True False False False False As for not we have: >>> not True False >>> not False True Boolean operators also follow similar left-to-right, parenthetical logic to arithmetic operators. >>> not True and True False >>> not False or ( True and False ) True str Strings are a sequence of characters, which can include digits and non-Latin characters. To define a string, put whatever you want to say between double (or single, just be consistent) quotes, like this: \"whatever you want to say\" . Types are important! >>> a = \"3\" >>> b = 3 >>> type ( a ) < class ' str '> >>> type ( b ) < class ' int '> >>> a + b Traceback ( most recent call last ): File \"<pyshell#8>\" , line 1 , in < module > a + b TypeError : can only concatenate str ( not \"int\" ) to str See that we cannot add \"3\" with 3, as \"3\" is not of type int ; it is a str . String processing Concatenation Concatenation is when you take one string and smoosh it with another one, using the + operator. You may also use print(..., ...) . By separating the variables with a comma, they will be printed, separated by a space. This does not only work for strings, but variables of other types too. However, concatenation using + only works on strings. >>> \"a\" + \"b\" 'ab' >>> print ( \"a\" , True , \"b\" , 1 ) a True b 1 >>> print ( \"a\" + True + \"b\" + 1 ) Traceback ( most recent call last ): File \"<pyshell#9>\" , line 1 , in < module > print ( \"a\" + True + \"b\" + 1 ) TypeError : can only concatenate str ( not \"bool\" ) to str Other than \"adding\" strings, you can also \"multiply\" them! >>> \"a\" * 10 'aaaaaaaaaa' Indexing and Slicing Strings are essentially an ordered list of characters, and each character can be given an index , which helps to identify its relative position in the string. Let's say we have the String \"python\" . p y t h o n 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 >>> p = \"python\" >>> len ( p ) 6 >>> p [ 0 ] 'p' >>> p [ 4 ] 'o' >>> p [ - 4 ] 't' What we have just done is access the characters by their positive and negative index numbers, as shown by the table. The first character has the index 0 (this is because of zero indexing, something used extensively in coding), while the last character may be accessed with 5 or -1 (which may be more useful). To get the length of a string, use len() . What if we want to access a bunch of characters, not just one? >>> p [ 1 : 3 ] 'yt' >>> p [: 3 ] 'pyt' >>> p [: - 4 ] 'py' >>> p [: - 1 ] 'pytho' >>> p [:] 'python' >>> p [ 2 :] 'thon' [x:y] denotes a slice, which returns the characters starting from x (inclusive) to the character right before y (exclusive). This may seem counterintuitive, but that's how coding is. You will see more of this inclusive lower bound and exclusive upper bound convention in loops, when you use range() . Also, when the lower or upper bound is not written (e.g. [:-1] or [2:] ), we assume that the string starts/ends right from the start/end. Wait! There's more... >>> p [: 4 : 2 ] 'pt' >>> p [: - 1 : 3 ] 'ph' There are three arguments for slicing, written like this: [start:stop:step] . Step tells you that the string slicing will occur every \"step\"-th character. For example, for p[:4:2] , we extract the 0th letter, skip the 1st letter, get the 2nd letter, and once again skip the 3rd letter, thus obtaining \"pt\" ( \"p[y]t[h]\" ). You will see these three arguments when using range() too. NoneType There is only one object that corresponds to this type: None ! It is the value of empty variables, or the return value of functions that don't return anything. Nothing much. Type Casting Type casting converts the variable data type into another data type. There are two types of type casting: implicit and explicit. Implicit Implicit type casting occurs when Python automatically converts the data type by inferring what the user wants. >>> a = 1 >>> type ( a ) < class ' int '> >>> a += 0.1 >>> a 1.1 >>> type ( a ) < class ' float '> This example was shown earlier. See that the type(a) was automatically converted to float after another float 0.1 was added to it. Explicit Explicit type casting is performed by typing out certain functions to convert the type. Common type casting functions include: int() , float() , and str() . Wait... but since we already have implicit type casting, why would we ever need to explicitly convert the type? Here's why: >>> a = \"3\" >>> b = 2 >>> a + b Traceback ( most recent call last ): File \"<pyshell#3>\" , line 1 , in < module > a + b TypeError : can only concatenate str ( not \"int\" ) to str >>> a + str ( b ) '32' >>> int ( a ) + b 5 We cannot add a variable of type str with another of type int . However, by explicitly casting the type, we get either \"32\" (this is known as string concatenation , where additional strings are stuck onto the end of the previous one), or 5 (which is simply the addition of two variables of type int ). Beware of invalid (or seemingly invalid) type casting. For example: >>> int ( \"1.1\" ) Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > int ( \"1.1\" ) ValueError : invalid literal for int () with base 10 : '1.1' >>> int ( True ) 1 >>> int ( False ) 0 In Python, True has an integer value of 1, while False has an integer value of 0. This may be useful when integrating booleans with arithmetic operations. A bit more on int() and float() >>> float ( 1 ) 1.0 >>> int ( 1.1 ) 1 >>> int ( 1.999 ) 1 >>> int ( - 1.1 ) - 1 >>> int ( - 1.999 ) - 1 >>> int ( \"1\" ) 1 >>> int ( \"1.1\" ) Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > int ( \"1.1\" ) ValueError : invalid literal for int () with base 10 : '1.1' >>> float ( \"1.1\" ) 1.1 float() , when performed on an integer, simply converts it to a number with a decimal point. On the other hand, though, when int() is done on a float, converts its type to int , by ignoring everything after the decimal point. It is not the same as rounding up, down, or off! Nonetheless, it can still be useful sometimes. Also, you can convert variables of type str to type int or float . However int(\"1.1\") throws an error, so usually when dealing with numeric strings, use float() .","title":"Chapter 4 (Types)"},{"location":"Chapter-4-%28Types%29/#the-types-of-types","text":"Type Name Description Example int Integer Whole numbers 1 , -4 float Floating point Numbers with a decimal point 0.202 , 1.0 bool Boolean A logical value of either True or False only True , False str String An ordered sequence of characters \"Hello!\" , \"\u03b8\u03bf\u03b8\" , \"312\" NoneType None, or null A null value, which is different from 0 , \"\" , or False None ...and many more... But these four types are the most common ones that you will meet. Python is a dynamically typed (or untyped) language (as opposed to statically typed ones), which means that variables do not have a pre-set type, and can change types throughout the code. This also means that the coder does not need to define the type upon instantiating it. In other words, something like int a = 1 is not just unnecessary in Python; it throws an error! >>> a = 1 >>> type ( a ) < class ' int '> >>> a = True >>> type ( a ) < class ' bool '>","title":"The types of Types"},{"location":"Chapter-4-%28Types%29/#int-and-float","text":"These types should be quite familiar as you have seen them in earlier sections. >>> a = 1 >>> type ( a ) < class ' int '> >>> a += 0.1 >>> a 1.1 >>> type ( a ) < class ' float '> In the above example, you can see that when variables are instantiated as whole numbers, their assigned type is int . However, once operations (e.g. addition, multiplication) with variables of type float are performed on them, the original variable becomes a float too. However, do note that all divisions result in a float output. >>> type ( 4 / 2 ) < class ' float '>","title":"int and float"},{"location":"Chapter-4-%28Types%29/#bool","text":"This section should be the most logical. The only possible bool values are True and False ! Note that True and False must be capitalised! There are still some things to introduce, though, and these are the boolean operators and , or , and not . a b a and b a or b True True True True True False False True False True False True False False False False As for not we have: >>> not True False >>> not False True Boolean operators also follow similar left-to-right, parenthetical logic to arithmetic operators. >>> not True and True False >>> not False or ( True and False ) True","title":"bool"},{"location":"Chapter-4-%28Types%29/#str","text":"Strings are a sequence of characters, which can include digits and non-Latin characters. To define a string, put whatever you want to say between double (or single, just be consistent) quotes, like this: \"whatever you want to say\" . Types are important! >>> a = \"3\" >>> b = 3 >>> type ( a ) < class ' str '> >>> type ( b ) < class ' int '> >>> a + b Traceback ( most recent call last ): File \"<pyshell#8>\" , line 1 , in < module > a + b TypeError : can only concatenate str ( not \"int\" ) to str See that we cannot add \"3\" with 3, as \"3\" is not of type int ; it is a str .","title":"str"},{"location":"Chapter-4-%28Types%29/#string-processing","text":"","title":"String processing"},{"location":"Chapter-4-%28Types%29/#concatenation","text":"Concatenation is when you take one string and smoosh it with another one, using the + operator. You may also use print(..., ...) . By separating the variables with a comma, they will be printed, separated by a space. This does not only work for strings, but variables of other types too. However, concatenation using + only works on strings. >>> \"a\" + \"b\" 'ab' >>> print ( \"a\" , True , \"b\" , 1 ) a True b 1 >>> print ( \"a\" + True + \"b\" + 1 ) Traceback ( most recent call last ): File \"<pyshell#9>\" , line 1 , in < module > print ( \"a\" + True + \"b\" + 1 ) TypeError : can only concatenate str ( not \"bool\" ) to str Other than \"adding\" strings, you can also \"multiply\" them! >>> \"a\" * 10 'aaaaaaaaaa'","title":"Concatenation"},{"location":"Chapter-4-%28Types%29/#indexing-and-slicing","text":"Strings are essentially an ordered list of characters, and each character can be given an index , which helps to identify its relative position in the string. Let's say we have the String \"python\" . p y t h o n 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 >>> p = \"python\" >>> len ( p ) 6 >>> p [ 0 ] 'p' >>> p [ 4 ] 'o' >>> p [ - 4 ] 't' What we have just done is access the characters by their positive and negative index numbers, as shown by the table. The first character has the index 0 (this is because of zero indexing, something used extensively in coding), while the last character may be accessed with 5 or -1 (which may be more useful). To get the length of a string, use len() . What if we want to access a bunch of characters, not just one? >>> p [ 1 : 3 ] 'yt' >>> p [: 3 ] 'pyt' >>> p [: - 4 ] 'py' >>> p [: - 1 ] 'pytho' >>> p [:] 'python' >>> p [ 2 :] 'thon' [x:y] denotes a slice, which returns the characters starting from x (inclusive) to the character right before y (exclusive). This may seem counterintuitive, but that's how coding is. You will see more of this inclusive lower bound and exclusive upper bound convention in loops, when you use range() . Also, when the lower or upper bound is not written (e.g. [:-1] or [2:] ), we assume that the string starts/ends right from the start/end. Wait! There's more... >>> p [: 4 : 2 ] 'pt' >>> p [: - 1 : 3 ] 'ph' There are three arguments for slicing, written like this: [start:stop:step] . Step tells you that the string slicing will occur every \"step\"-th character. For example, for p[:4:2] , we extract the 0th letter, skip the 1st letter, get the 2nd letter, and once again skip the 3rd letter, thus obtaining \"pt\" ( \"p[y]t[h]\" ). You will see these three arguments when using range() too.","title":"Indexing and Slicing"},{"location":"Chapter-4-%28Types%29/#nonetype","text":"There is only one object that corresponds to this type: None ! It is the value of empty variables, or the return value of functions that don't return anything. Nothing much.","title":"NoneType"},{"location":"Chapter-4-%28Types%29/#type-casting","text":"Type casting converts the variable data type into another data type. There are two types of type casting: implicit and explicit.","title":"Type Casting"},{"location":"Chapter-4-%28Types%29/#implicit","text":"Implicit type casting occurs when Python automatically converts the data type by inferring what the user wants. >>> a = 1 >>> type ( a ) < class ' int '> >>> a += 0.1 >>> a 1.1 >>> type ( a ) < class ' float '> This example was shown earlier. See that the type(a) was automatically converted to float after another float 0.1 was added to it.","title":"Implicit"},{"location":"Chapter-4-%28Types%29/#explicit","text":"Explicit type casting is performed by typing out certain functions to convert the type. Common type casting functions include: int() , float() , and str() . Wait... but since we already have implicit type casting, why would we ever need to explicitly convert the type? Here's why: >>> a = \"3\" >>> b = 2 >>> a + b Traceback ( most recent call last ): File \"<pyshell#3>\" , line 1 , in < module > a + b TypeError : can only concatenate str ( not \"int\" ) to str >>> a + str ( b ) '32' >>> int ( a ) + b 5 We cannot add a variable of type str with another of type int . However, by explicitly casting the type, we get either \"32\" (this is known as string concatenation , where additional strings are stuck onto the end of the previous one), or 5 (which is simply the addition of two variables of type int ). Beware of invalid (or seemingly invalid) type casting. For example: >>> int ( \"1.1\" ) Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > int ( \"1.1\" ) ValueError : invalid literal for int () with base 10 : '1.1' >>> int ( True ) 1 >>> int ( False ) 0 In Python, True has an integer value of 1, while False has an integer value of 0. This may be useful when integrating booleans with arithmetic operations.","title":"Explicit"},{"location":"Chapter-4-%28Types%29/#a-bit-more-on-int-and-float","text":">>> float ( 1 ) 1.0 >>> int ( 1.1 ) 1 >>> int ( 1.999 ) 1 >>> int ( - 1.1 ) - 1 >>> int ( - 1.999 ) - 1 >>> int ( \"1\" ) 1 >>> int ( \"1.1\" ) Traceback ( most recent call last ): File \"<pyshell#2>\" , line 1 , in < module > int ( \"1.1\" ) ValueError : invalid literal for int () with base 10 : '1.1' >>> float ( \"1.1\" ) 1.1 float() , when performed on an integer, simply converts it to a number with a decimal point. On the other hand, though, when int() is done on a float, converts its type to int , by ignoring everything after the decimal point. It is not the same as rounding up, down, or off! Nonetheless, it can still be useful sometimes. Also, you can convert variables of type str to type int or float . However int(\"1.1\") throws an error, so usually when dealing with numeric strings, use float() .","title":"A bit more on int() and float()"},{"location":"Chapter-5-%28Conditionals%29/","text":"Ignore this, I will come back to this later With the tools you have, you should be able to write programs like a simple addition calculator: print ( \"Addition Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) result = num_1 + num_2 print ( \"The answer is \" + str ( result )) Notice that every line of code will run sequentially. No line will be skipped during execution. Now, we wish to extend this to the four arithmetic operations: addition, subtraction, multiplication and division. The user not only needs to specify the two numbers but also what type of operation they want to carry out. But how do you do this? We will have to code four different lines for the four different operations, but we only want the relevant line to run! #Python runs all the lines in order. The final value of result will always be num_1 divided by num_2, since it replaces the previous values in the last line result = num_1 + num_2 result = num_1 - num_2 result = num_1 * num_2 result = num_1 / num_2 This is where if statements come in. The structure of an if statement goes: if ( condition ): #These lines will only execute if condition is True So now we can write our calculator program: print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 if ( operation == \"/\" ): result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False Since the only four options are +, -, * or /, we need not check in the last if statement if operation == \"/\" . We can just assume it is \"/\", since there are no other options.","title":"Chapter 5 (Conditionals)"},{"location":"Chapter-5-%28Conditionals%29/#ignore-this-i-will-come-back-to-this-later","text":"With the tools you have, you should be able to write programs like a simple addition calculator: print ( \"Addition Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) result = num_1 + num_2 print ( \"The answer is \" + str ( result )) Notice that every line of code will run sequentially. No line will be skipped during execution. Now, we wish to extend this to the four arithmetic operations: addition, subtraction, multiplication and division. The user not only needs to specify the two numbers but also what type of operation they want to carry out. But how do you do this? We will have to code four different lines for the four different operations, but we only want the relevant line to run! #Python runs all the lines in order. The final value of result will always be num_1 divided by num_2, since it replaces the previous values in the last line result = num_1 + num_2 result = num_1 - num_2 result = num_1 * num_2 result = num_1 / num_2 This is where if statements come in. The structure of an if statement goes: if ( condition ): #These lines will only execute if condition is True So now we can write our calculator program: print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 if ( operation == \"/\" ): result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False Since the only four options are +, -, * or /, we need not check in the last if statement if operation == \"/\" . We can just assume it is \"/\", since there are no other options.","title":"Ignore this, I will come back to this later"},{"location":"Chapter-6-%28Functions%29/","text":"Agenda 1) What is a function? 1.1) Concept of Functions 1.2) Defining a Function 1.3) Calling a Function 2) Functions as Objects What is a Function? Concept of Functions A function a block of code that can be \"Called\", or run, by other pieces of code. While this may not at first seem very useful, it enables Code Reuse, which is the practice of writing as little unnecessary code as possible to achieve a given outcome. For example, instead of writing out code to say \"Hello World!\", we can instead define a function named say_hello_world, and call it every time we want to say \"Hello World!\". Defining a Function Functions are defined by the keyword def, as below: def say_hello_world(): Note the round brackets (parentheses). These will be important later. Now, for the rest of the code. def say_hello_world(): print(\"Hello World!\") Now, let's use a more serious example. Say that you want to write a piece of code to do some math, and have to work with geometry. As you may have learned in Primary School, the Pythagorean Theorem is very useful when trying solve mathematics concerning triangles. Problem is, it's a bit of a hassle to type out. Let's fix that, shall we? def pythagoras(x, y): Notice the (x, y) above. Here, x and y are what are known as parameters, or arguments, which can be thought of as the inputs to the function. In Python, functions can accept almost anything as parameters, though most functions only work for parameters of specific types. In our case, our function will only work if x and y are both some kind of number. Now, for the code. def pythagoras(x, y): h = (x*x + y*y) ** 0.5 return h The \"return\" keyword specifies what the function chooses to output. However, the \"return\" keyworld also works as a sort of stop sign, in that it runs after everything in the same line, and stops any lines after it from running. Let's use that information to streamline things. (Note that raising something to the power of one half is mathematically equiviant to taking its square root instead.) def pythagoras(x, y): return (x*x + y*y) ** 0.5 Calling a Function Once a function has been defined, it must naturally be called where needed. This is generally done by typing in the function's name, along with any parameters in parentheses. For example: print(pythagoras(3, 4)) #this prints \"5\" Function calls can also be used to assign values to variables. hypotenuse = pythagoras(3, 4) print(hypotenuse) #this prints \"5\" A function that returns multiple variables at once returns them in the form of a list, which is frequently \"unpacked\", or turned into individual variables, immediately. When calling a function, make sure to include the parentheses, or you'll get a strange output that we'll discuss later. def return_two_values(x, y): return x + 1, y - 1 print(return_two_variables(2, 5)) #this prints \"(2, 5)\" x1, y1 = return_two_values(2, 5) print(x1) #this prints 3 print(y1) #this prints 4 Functions as Objects This following section is somewhat advanced reading, and will be skimmed over in class. Previously, it was mentioned that functions can take just about anything as parameters. This includes other functions. To pass a function as a parameter, simply do something along the lines of the following. The exact functions don't matter that much, this is just an example. def polynomial(x): return (x+1)*(x-1)*x def explore_polynomial(poly_func): epsilon = 0.0001 x = 5 #arbitrary values for demonstration y = 5 while abs(y) > epsilon: y = poly_func(x) grad = (poly_func(x + epsilon)-poly_func(x - epsilon))/(2*epsilon) offset = -y/grad x = x + offset print(y) print(\"\\n\") #actually prints 2 new lines return x print(explore_polynomial(polynomial)) #returns the following 120 35.180542127086106 10.167302591532751 2.8333968080604004 0.7134911212948255 0.13199367113508667 0.009667028706160917 6.832732941427076e-05 1.000000001750586 As you can see here, what's happening is that we're passing the function name \"polynomial\" as a parameter, and in the function we are calling that same function name. Note that when passing the polynomial function into explore_polynomial, we do not include any parentheses or parameters for the polynomial function itself. That is because the inclusion of parentheses would result in a call to the function itself, and the result of that call would then be passed into explore_polynomial, rather than the polynomial function. This leads to a bigger topic, which may explain why you might have come across some strange behaviour when calling functions. For example, neclecting to include the parentheses when printing the explore_polynomial nets you the following: print(explore_polynomial) <function explore_polynomial at 0x7fe4866d1e50> Notice the strange series of numbers and characters in the message? Those characters and numbers refer to something called the \"Memory Address\" of the function explore_polynomial. The Memory Address refers to where in your computer's physical RAM stick the object in question, the function in this case, is loaded. If your numbers and characters are different, that's normal. At our current \"level\" of programming, we have no control over what objects go to what memory addresses, so you don't have to worry about the specifics of them. Why does this matter to you then? Because this explains a lot of strange behaviour. It explains why the following code works the way it does, for example. list1 = [1,2,3,4] list2 = list1 print(list1) #prints \"[1, 2, 3, 4]\" print(list2) #also prints \"[1, 2, 3, 4]\" print(list1[1]) #prints \"2\" list1[1] = 3 list1[3] = 7 print(list1) #prints \"[1, 3, 3, 7]\" print(list2) #...also prints \"[1, 3, 3, 7]\"? Now that we know about memory addresses, the problem here makes sense. When we tell the computer that list2 = list1, it's not actually duplicating [1, 2, 3, 4]. Instead, it's assigning the Memory Address of that particular list, [1, 2, 3, 4], that is already assigned to list1, to list 2. And when we tell the computer to change the value of some elements of that particular list [1, 2, 3, 4], both list1 and list2 reflect the change, because they're two different variable names that both refer to the same memory address.","title":"Chapter 6 (Functions)"},{"location":"Chapter-6-%28Functions%29/#agenda","text":"1) What is a function? 1.1) Concept of Functions 1.2) Defining a Function 1.3) Calling a Function 2) Functions as Objects","title":"Agenda"},{"location":"Chapter-6-%28Functions%29/#what-is-a-function","text":"","title":"What is a Function?"},{"location":"Chapter-6-%28Functions%29/#concept-of-functions","text":"A function a block of code that can be \"Called\", or run, by other pieces of code. While this may not at first seem very useful, it enables Code Reuse, which is the practice of writing as little unnecessary code as possible to achieve a given outcome. For example, instead of writing out code to say \"Hello World!\", we can instead define a function named say_hello_world, and call it every time we want to say \"Hello World!\".","title":"Concept of Functions"},{"location":"Chapter-6-%28Functions%29/#defining-a-function","text":"Functions are defined by the keyword def, as below: def say_hello_world(): Note the round brackets (parentheses). These will be important later. Now, for the rest of the code. def say_hello_world(): print(\"Hello World!\") Now, let's use a more serious example. Say that you want to write a piece of code to do some math, and have to work with geometry. As you may have learned in Primary School, the Pythagorean Theorem is very useful when trying solve mathematics concerning triangles. Problem is, it's a bit of a hassle to type out. Let's fix that, shall we? def pythagoras(x, y): Notice the (x, y) above. Here, x and y are what are known as parameters, or arguments, which can be thought of as the inputs to the function. In Python, functions can accept almost anything as parameters, though most functions only work for parameters of specific types. In our case, our function will only work if x and y are both some kind of number. Now, for the code. def pythagoras(x, y): h = (x*x + y*y) ** 0.5 return h The \"return\" keyword specifies what the function chooses to output. However, the \"return\" keyworld also works as a sort of stop sign, in that it runs after everything in the same line, and stops any lines after it from running. Let's use that information to streamline things. (Note that raising something to the power of one half is mathematically equiviant to taking its square root instead.) def pythagoras(x, y): return (x*x + y*y) ** 0.5","title":"Defining a Function"},{"location":"Chapter-6-%28Functions%29/#calling-a-function","text":"Once a function has been defined, it must naturally be called where needed. This is generally done by typing in the function's name, along with any parameters in parentheses. For example: print(pythagoras(3, 4)) #this prints \"5\" Function calls can also be used to assign values to variables. hypotenuse = pythagoras(3, 4) print(hypotenuse) #this prints \"5\" A function that returns multiple variables at once returns them in the form of a list, which is frequently \"unpacked\", or turned into individual variables, immediately. When calling a function, make sure to include the parentheses, or you'll get a strange output that we'll discuss later. def return_two_values(x, y): return x + 1, y - 1 print(return_two_variables(2, 5)) #this prints \"(2, 5)\" x1, y1 = return_two_values(2, 5) print(x1) #this prints 3 print(y1) #this prints 4","title":"Calling a Function"},{"location":"Chapter-6-%28Functions%29/#functions-as-objects","text":"This following section is somewhat advanced reading, and will be skimmed over in class. Previously, it was mentioned that functions can take just about anything as parameters. This includes other functions. To pass a function as a parameter, simply do something along the lines of the following. The exact functions don't matter that much, this is just an example. def polynomial(x): return (x+1)*(x-1)*x def explore_polynomial(poly_func): epsilon = 0.0001 x = 5 #arbitrary values for demonstration y = 5 while abs(y) > epsilon: y = poly_func(x) grad = (poly_func(x + epsilon)-poly_func(x - epsilon))/(2*epsilon) offset = -y/grad x = x + offset print(y) print(\"\\n\") #actually prints 2 new lines return x print(explore_polynomial(polynomial)) #returns the following 120 35.180542127086106 10.167302591532751 2.8333968080604004 0.7134911212948255 0.13199367113508667 0.009667028706160917 6.832732941427076e-05 1.000000001750586 As you can see here, what's happening is that we're passing the function name \"polynomial\" as a parameter, and in the function we are calling that same function name. Note that when passing the polynomial function into explore_polynomial, we do not include any parentheses or parameters for the polynomial function itself. That is because the inclusion of parentheses would result in a call to the function itself, and the result of that call would then be passed into explore_polynomial, rather than the polynomial function. This leads to a bigger topic, which may explain why you might have come across some strange behaviour when calling functions. For example, neclecting to include the parentheses when printing the explore_polynomial nets you the following: print(explore_polynomial) <function explore_polynomial at 0x7fe4866d1e50> Notice the strange series of numbers and characters in the message? Those characters and numbers refer to something called the \"Memory Address\" of the function explore_polynomial. The Memory Address refers to where in your computer's physical RAM stick the object in question, the function in this case, is loaded. If your numbers and characters are different, that's normal. At our current \"level\" of programming, we have no control over what objects go to what memory addresses, so you don't have to worry about the specifics of them. Why does this matter to you then? Because this explains a lot of strange behaviour. It explains why the following code works the way it does, for example. list1 = [1,2,3,4] list2 = list1 print(list1) #prints \"[1, 2, 3, 4]\" print(list2) #also prints \"[1, 2, 3, 4]\" print(list1[1]) #prints \"2\" list1[1] = 3 list1[3] = 7 print(list1) #prints \"[1, 3, 3, 7]\" print(list2) #...also prints \"[1, 3, 3, 7]\"? Now that we know about memory addresses, the problem here makes sense. When we tell the computer that list2 = list1, it's not actually duplicating [1, 2, 3, 4]. Instead, it's assigning the Memory Address of that particular list, [1, 2, 3, 4], that is already assigned to list1, to list 2. And when we tell the computer to change the value of some elements of that particular list [1, 2, 3, 4], both list1 and list2 reflect the change, because they're two different variable names that both refer to the same memory address.","title":"Functions as Objects"},{"location":"Chapter-7-%28Loops%29/","text":"A loop is used for executing code multiple times. There are two commonly-used loop types in Python: the while and for loops. The while loop repeats the code inside it as long as a certain condition is satisfied. Once that condition stops being satisfied, the program continues. import time timer = 0 while timer < 10 : print ( \"Elapsed time: \" + timer + \"/10s\" ) timer += 1 time . sleep ( 1 ) print ( Timer over )","title":"Chapter 7 (Loops)"},{"location":"Chapter-8-%28Arrays%29/","text":"In this lesson, we will learn what an array is and how it is useful. Let's code a list of crew members in variables. crew_member_0 = \"Clay\" crew_member_1 = \"George\" crew_member_2 = \"Nick\" crew_member_3 = \"Alex\" crew_member_4 = \"Karl\" crew_member_5 = \"Cal\" crew_member_6 = \"Alyssa\" crew_member_7 = \"Thomas\" crew_member_8 = \"Toby\" crew_member_9 = \"Wilbur\" This isn't a very good way of doing things - we can't loop over the crew members, and we can't do things like removing members easily. And what if instead of 10 crew members, we had 1,000? An array is a special type of variable which holds many values. We can code our 10 crew members in an array like so: crew_members = [ \"Clay\" , \"George\" , \"Nick\" , \"Alex\" , \"Karl\" , \"Cal\" , \"Alyssa\" , \"Thomas\" , \"Toby\" , \"Wilbur\" ] You can refer to individual elements of an array with their index number: print ( \"The first crew member is \" + crew_members [ 0 ]) print ( \"The eighth crew member is \" + crew_members [ 7 ]) Remember that in Python, we start counting from 0 ! We can also modify elements of an array. For most cases, a reference to an array element crew_members[0] is just like a reference to a variable crew_member_0 . crew_members [ 5 ] = \"Red\" The for loop iterates over an array it is given. In other words, it can be used to execute code for each member of the array. print ( \"The crew members are:\" ) for i in crew_members : print ( i )","title":"Chapter 8 (Arrays)"},{"location":"Chapter-8-%28Loops%29/","text":"Let's make a program which prints a list of items. crew_members = [ \"Clay\" , \"George\" , \"Nick\" , \"Alex\" , \"Karl\" ] print ( \"The crew members are:\" ) print ( crew_members [ 0 ]) print ( crew_members [ 1 ]) print ( crew_members [ 2 ]) print ( crew_members [ 3 ]) print ( crew_members [ 4 ]) This program works... but it's tedious to write a line for every list entry. A loop is a way to perform lines of code multiple times. Let's take a look at an example of a loop. crew_members = [ \"Clay\" , \"George\" , \"Nick\" , \"Alex\" , \"Karl\" ] print ( \"The crew members are:\" ) for i in crew_members : print ( i ) The for loop executes code inside it once for each element of the list it is given. In the example, for each name in the list, it will print it. And if the list becomes longer... crew_members = [ \"Clay\" , \"George\" , \"Nick\" , \"Alex\" , \"Karl\" , \"Cal\" , \"Alyssa\" , \"Thomas\" , \"Toby\" , \"Wilbur\" ] the loop can handle it with no problem. Nested loops: Prime number sieve of Big E","title":"Chapter 8 (Loops)"},{"location":"Chapter-9-%28Modules-and-Packages%29/","text":"What are modules Modules are .py files containing useful snippets of code that are put inside functions. We are allowed to call those functions to perform complicated tasks that we do not have to program out ourselves. Other people have already done the legwork in making the functions, simplified their use, and shared it with us using modules. What are packages Packages are a collection of modules, often grouping together modules under a common purpose, for example one package might be created for images, and one module inside could group together displaying an image, while another module could handle making alterations to the image. You are also able to create your own packages, although that is not covered in these notes, there will be links to supplementary materials at the end if you are interested. The Math Module The Math module is part of the python standard library, and contains many commonly used mathematical functions. These are some of the categories of functions that the Math module provides us access to. math \u2014 Mathematical functions Number-theoretic and representation functions \\ Power and logarithmic functions \\ Trigonometric functions \\ Angular conversion \\ Hyperbolic functions \\ Special functions \\ Constants Importing the Math module Importing is how we gain access to all the functions defined inside a module. \\ We can import the Math module with the following simple line of code. By convention, import statements are placed at the top of your program.\\ import math What are some useful functions of the math library? >>> import math >>> math . pi 3.141592653589793 >>> math . ceil ( 1.5 ) 2 >>> math . floor ( 1.5 ) 1 >>> math . sqrt ( 64 ) 8.0 Lets break down the above lines of code. >>> import math We imported the math module for our use. >>> math . pi 3.141592653589793 This returns the float value of the first few digits of the mathematical value of \u03c0 ( pi ), to which is of course 3.141592653589793 . >>> math . ceil ( 1.5 ) 2 The math.ceil function will take in a float as input, and rounds a number UP to the nearest integer, in this case rounding up 1.5 would return 2 . >>> math . floor ( 1.5 ) 1 The math.floor function will take in a float as input, and rounds a number DOWN to the nearest integer, in this case rounding down 1.5 would return 1 . >>> math . sqrt ( 64 ) 8 The math.sqrt function will take in a number as input, and returns the square root, in this case the square root of 64 is 8 . Importing the Random module Now we will import the random module, allowing us to obtain random numbers without having to write our own random functions. >>> import random >>> random . seed ( 1337 ) >>> random . random () 0.6177528569514706 >>> random . randrange ( 10 , 20 ) 18 >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 >>> random . seed ( 1337 ) >>> random . random () 0.6177528569514706 >>> random . randrange ( 10 , 20 ) 18 >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 What's happening here? >>> random . random 0.6177528569514706 This generates a float value between 0 and 1. >>> random . randrange ( 10 , 20 ) 18 The randrange function will generate a randomly selected integer between any two numbers, but excluding the last number. In this case, it will generate a number between 10 and 20, but not including 20. >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 The choice function will choose a random element from a non empty sequence, in this case, it chose the number 3 from the sequence. \\ But, those numbers are repeating and random numbers should not repeat right? Actually, using the random.seed() function, we have seeded the random number generator. The act of seeding, initializes the program with that specific number, generating random numbers based on the seed. Passing in the same seed, going through the same steps, will result in the same random numbers being generated. Importing the Antigravity Module Now try importing the \"antigravity\" module like we did for the above modules. Did anything interesting happen? Click to expand for the answer If it opened up to this XKCD comic, it worked! \\ ![](https://imgs.xkcd.com/comics/python.png) \\ It's actually a fun easter egg, explained [here](http://python-history.blogspot.com/2010/06/import-antigravity.html). Conclusion and Extra Readings There are many packages available for our use, and you have learnt how to import them. Here is a list of the python standard libraries we can import. Additionally, if you are interested, you can read up on how to create your own package .","title":"Chapter 9 (Modules and Packages)"},{"location":"Chapter-9-%28Modules-and-Packages%29/#what-are-modules","text":"Modules are .py files containing useful snippets of code that are put inside functions. We are allowed to call those functions to perform complicated tasks that we do not have to program out ourselves. Other people have already done the legwork in making the functions, simplified their use, and shared it with us using modules.","title":"What are modules"},{"location":"Chapter-9-%28Modules-and-Packages%29/#what-are-packages","text":"Packages are a collection of modules, often grouping together modules under a common purpose, for example one package might be created for images, and one module inside could group together displaying an image, while another module could handle making alterations to the image. You are also able to create your own packages, although that is not covered in these notes, there will be links to supplementary materials at the end if you are interested.","title":"What are packages"},{"location":"Chapter-9-%28Modules-and-Packages%29/#the-math-module","text":"The Math module is part of the python standard library, and contains many commonly used mathematical functions. These are some of the categories of functions that the Math module provides us access to. math \u2014 Mathematical functions Number-theoretic and representation functions \\ Power and logarithmic functions \\ Trigonometric functions \\ Angular conversion \\ Hyperbolic functions \\ Special functions \\ Constants","title":"The Math Module"},{"location":"Chapter-9-%28Modules-and-Packages%29/#importing-the-math-module","text":"Importing is how we gain access to all the functions defined inside a module. \\ We can import the Math module with the following simple line of code. By convention, import statements are placed at the top of your program.\\ import math What are some useful functions of the math library? >>> import math >>> math . pi 3.141592653589793 >>> math . ceil ( 1.5 ) 2 >>> math . floor ( 1.5 ) 1 >>> math . sqrt ( 64 ) 8.0 Lets break down the above lines of code. >>> import math We imported the math module for our use. >>> math . pi 3.141592653589793 This returns the float value of the first few digits of the mathematical value of \u03c0 ( pi ), to which is of course 3.141592653589793 . >>> math . ceil ( 1.5 ) 2 The math.ceil function will take in a float as input, and rounds a number UP to the nearest integer, in this case rounding up 1.5 would return 2 . >>> math . floor ( 1.5 ) 1 The math.floor function will take in a float as input, and rounds a number DOWN to the nearest integer, in this case rounding down 1.5 would return 1 . >>> math . sqrt ( 64 ) 8 The math.sqrt function will take in a number as input, and returns the square root, in this case the square root of 64 is 8 .","title":"Importing the Math module"},{"location":"Chapter-9-%28Modules-and-Packages%29/#importing-the-random-module","text":"Now we will import the random module, allowing us to obtain random numbers without having to write our own random functions. >>> import random >>> random . seed ( 1337 ) >>> random . random () 0.6177528569514706 >>> random . randrange ( 10 , 20 ) 18 >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 >>> random . seed ( 1337 ) >>> random . random () 0.6177528569514706 >>> random . randrange ( 10 , 20 ) 18 >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 What's happening here? >>> random . random 0.6177528569514706 This generates a float value between 0 and 1. >>> random . randrange ( 10 , 20 ) 18 The randrange function will generate a randomly selected integer between any two numbers, but excluding the last number. In this case, it will generate a number between 10 and 20, but not including 20. >>> random . choice ([ 1 , 2 , 3 , 4 , 5 ]) 3 The choice function will choose a random element from a non empty sequence, in this case, it chose the number 3 from the sequence. \\ But, those numbers are repeating and random numbers should not repeat right? Actually, using the random.seed() function, we have seeded the random number generator. The act of seeding, initializes the program with that specific number, generating random numbers based on the seed. Passing in the same seed, going through the same steps, will result in the same random numbers being generated.","title":"Importing the Random module"},{"location":"Chapter-9-%28Modules-and-Packages%29/#importing-the-antigravity-module","text":"Now try importing the \"antigravity\" module like we did for the above modules. Did anything interesting happen? Click to expand for the answer If it opened up to this XKCD comic, it worked! \\ ![](https://imgs.xkcd.com/comics/python.png) \\ It's actually a fun easter egg, explained [here](http://python-history.blogspot.com/2010/06/import-antigravity.html).","title":"Importing the Antigravity Module"},{"location":"Chapter-9-%28Modules-and-Packages%29/#conclusion-and-extra-readings","text":"There are many packages available for our use, and you have learnt how to import them. Here is a list of the python standard libraries we can import. Additionally, if you are interested, you can read up on how to create your own package .","title":"Conclusion and Extra Readings"},{"location":"Getting%20Started/","text":"Getting Started How do you use astrosite ? Here's a guide for you. Step 1: Create a Repo Create a repo by going to the astrosite repo and clicking \"Use this template\" as shown below: This will lead you to another page to generate a repository from this template as shown below. Make sure to create this repo in the NUSH-Astro GitHub Organisation and Provide a useful name and description for the repo. Make sure to make the repo public, otherwise deployment is not possible. Click \"Create repository from template\" when done. Step 2: Deal with the Repo This will lead you to the newly created GitHub Repo, in this case https://github.com/NUSH-Astro/cosmology , and you can now click the \"Code\" button and copy the Repo address as shown. This will be useful for downloading the repo and then administrating it. Next, go to your terminal (for the purposes of this tutorial, I am using Git Bash), and clone the repository into a specific folder. Now, move into this newly created folder and run ./setup.sh on some bash-supporting terminal. Step 3: Set-Up and Installation This installation expects that you already have Python and Git Installed. If you don't, do install them from relevant sources. Next, the setup file will install mkdocs and mkdocs-material from pip , allowing you to now convert these markdown files to HTML. Following this, it will open a Nano tab to input the name of the site. Make sure to convert astrosite to your preferred domain choice (domain choices have been stated, but can be added by contacting Prannaya), in this case cosmo . Press Ctrl-O , Enter and Ctrl-X when you are done. Now, the setup file will deploy the site and you should probably be able to see the following messages: This is mostly unimportant, but the main thing to note is that the CNAME file has been updated. Step 4: Minor Bugfixes Now, need to open the mkdocs.yml file to change the name of the Site, simply by typing nano mkdocs.yml as shown. From here, it opens the Nano Tab and you can change the site name from AstroSite to any name, containing some reference to the topic at hand. In this case, it has been renamed to Cosmology . Press Ctrl-O , Enter and Ctrl-X when you are done. Step 5: Deploy and Commit From here, you can now deploy the site again by typing out ./deploy.sh as shown. From here, the site is now being deployed, and you can visit it in about 3 or 4 minutes. Till then, you can push the repo up by doing the following commands: After this, you can simply access it from the site, in this case http://cosmo.nushastro.ml/ , as shown below: And there you have it! A working site with editability based on Markdown (which also happens to support MathJax). I hope this helps you use this site. Thank you.","title":"Getting Started"},{"location":"Getting%20Started/#getting-started","text":"How do you use astrosite ? Here's a guide for you.","title":"Getting Started"},{"location":"Getting%20Started/#step-1-create-a-repo","text":"Create a repo by going to the astrosite repo and clicking \"Use this template\" as shown below: This will lead you to another page to generate a repository from this template as shown below. Make sure to create this repo in the NUSH-Astro GitHub Organisation and Provide a useful name and description for the repo. Make sure to make the repo public, otherwise deployment is not possible. Click \"Create repository from template\" when done.","title":"Step 1: Create a Repo"},{"location":"Getting%20Started/#step-2-deal-with-the-repo","text":"This will lead you to the newly created GitHub Repo, in this case https://github.com/NUSH-Astro/cosmology , and you can now click the \"Code\" button and copy the Repo address as shown. This will be useful for downloading the repo and then administrating it. Next, go to your terminal (for the purposes of this tutorial, I am using Git Bash), and clone the repository into a specific folder. Now, move into this newly created folder and run ./setup.sh on some bash-supporting terminal.","title":"Step 2: Deal with the Repo"},{"location":"Getting%20Started/#step-3-set-up-and-installation","text":"This installation expects that you already have Python and Git Installed. If you don't, do install them from relevant sources. Next, the setup file will install mkdocs and mkdocs-material from pip , allowing you to now convert these markdown files to HTML. Following this, it will open a Nano tab to input the name of the site. Make sure to convert astrosite to your preferred domain choice (domain choices have been stated, but can be added by contacting Prannaya), in this case cosmo . Press Ctrl-O , Enter and Ctrl-X when you are done. Now, the setup file will deploy the site and you should probably be able to see the following messages: This is mostly unimportant, but the main thing to note is that the CNAME file has been updated.","title":"Step 3: Set-Up and Installation"},{"location":"Getting%20Started/#step-4-minor-bugfixes","text":"Now, need to open the mkdocs.yml file to change the name of the Site, simply by typing nano mkdocs.yml as shown. From here, it opens the Nano Tab and you can change the site name from AstroSite to any name, containing some reference to the topic at hand. In this case, it has been renamed to Cosmology . Press Ctrl-O , Enter and Ctrl-X when you are done.","title":"Step 4: Minor Bugfixes"},{"location":"Getting%20Started/#step-5-deploy-and-commit","text":"From here, you can now deploy the site again by typing out ./deploy.sh as shown. From here, the site is now being deployed, and you can visit it in about 3 or 4 minutes. Till then, you can push the repo up by doing the following commands: After this, you can simply access it from the site, in this case http://cosmo.nushastro.ml/ , as shown below: And there you have it! A working site with editability based on Markdown (which also happens to support MathJax). I hope this helps you use this site. Thank you.","title":"Step 5: Deploy and Commit"},{"location":"Home/","text":"Welcome to the Python Coding Workshop! The Curriculum This Coding Workshop covers the fundamentals of the Python Programming Language, and is ideally taught over 3 Days with 2 Hours of Lessons per day. The topics are as follows: S/N Topic Sub-Topic 1 Intro to Python and IDLE Using print and input functions Accessing IDLE 2 Operations Basic Arithmetic ( + , - , * , / , // , % , ** ) Order and Operations (BODMAS/PEMDAS) 3 Variables & Assignment Box Analogy Assignment Statements ( = , += , -= , *= , /= \u2026) 4 Types int , float , bool , str , None Type Casting 5 Conditionals if Statement else Statement elif Statement and Control Flow 6 Loops for Loop while Loop 7 Functions Defining Functions return Statement and lambda Functions Functions as Objects (e.g. map , filter , etc.) 8 Arrays / Lists Storage, Append and Remove Indexing (and String Indexing) 9 External Libraries math Library random Library 10 Exceptions and Error Handling Exceptions try , except , else and finally Statements 11 External Systems Accessing the Command Line pip PyPI and numpy Docs (+ Debugger) Session Details Our sessions will take place from 16th to 18th March on Zoom or Teams. The current curriculum plan is as follows: Day Date Duration Topics Covered Day 1 16th March 2 Hours Topics 1 - 4 Day 2 17th March 2 Hours Topics 5 - 8 Day 3 18th March 2 Hours Topics 9 - 11 We have yet to trial run this curriculum, so we will require a lot more time to confirm this schedule. Lesson Plan Lesson 1 In lesson 1, we will be covering the following topics: 1. Intro to Python and IDLE (Expected Time: 15 minutes) 2. Operations (Expected Time: 15 minutes) 3. Variables and Assignments (Expected Time: 30 minutes) 4. Types (Expected Time: 50 minutes) Activities in Chapter 1 Lesson 2 Conditionals (Expected Time: 25 minutes) Functions (Expected Time: 30 minutes) Loops (Expected Time: 20 minutes) Arrays and Lists (Expected Time: 25 minutes) Lesson 3 Modules and Packages (Expected Time: 30 minutes) Exceptions (Expected Time: 25 minutes) External Systems - Going Forward (Expected Time: 55 minutes)","title":"Home"},{"location":"Home/#the-curriculum","text":"This Coding Workshop covers the fundamentals of the Python Programming Language, and is ideally taught over 3 Days with 2 Hours of Lessons per day. The topics are as follows: S/N Topic Sub-Topic 1 Intro to Python and IDLE Using print and input functions Accessing IDLE 2 Operations Basic Arithmetic ( + , - , * , / , // , % , ** ) Order and Operations (BODMAS/PEMDAS) 3 Variables & Assignment Box Analogy Assignment Statements ( = , += , -= , *= , /= \u2026) 4 Types int , float , bool , str , None Type Casting 5 Conditionals if Statement else Statement elif Statement and Control Flow 6 Loops for Loop while Loop 7 Functions Defining Functions return Statement and lambda Functions Functions as Objects (e.g. map , filter , etc.) 8 Arrays / Lists Storage, Append and Remove Indexing (and String Indexing) 9 External Libraries math Library random Library 10 Exceptions and Error Handling Exceptions try , except , else and finally Statements 11 External Systems Accessing the Command Line pip PyPI and numpy Docs (+ Debugger)","title":"The Curriculum"},{"location":"Home/#session-details","text":"Our sessions will take place from 16th to 18th March on Zoom or Teams. The current curriculum plan is as follows: Day Date Duration Topics Covered Day 1 16th March 2 Hours Topics 1 - 4 Day 2 17th March 2 Hours Topics 5 - 8 Day 3 18th March 2 Hours Topics 9 - 11 We have yet to trial run this curriculum, so we will require a lot more time to confirm this schedule.","title":"Session Details"},{"location":"Home/#lesson-plan","text":"","title":"Lesson Plan"},{"location":"Home/#lesson-1","text":"In lesson 1, we will be covering the following topics: 1. Intro to Python and IDLE (Expected Time: 15 minutes) 2. Operations (Expected Time: 15 minutes) 3. Variables and Assignments (Expected Time: 30 minutes) 4. Types (Expected Time: 50 minutes)","title":"Lesson 1"},{"location":"Home/#activities-in-chapter-1","text":"","title":"Activities in Chapter 1"},{"location":"Home/#lesson-2","text":"Conditionals (Expected Time: 25 minutes) Functions (Expected Time: 30 minutes) Loops (Expected Time: 20 minutes) Arrays and Lists (Expected Time: 25 minutes)","title":"Lesson 2"},{"location":"Home/#lesson-3","text":"Modules and Packages (Expected Time: 30 minutes) Exceptions (Expected Time: 25 minutes) External Systems - Going Forward (Expected Time: 55 minutes)","title":"Lesson 3"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/","text":"This is really nice and traditional innit So Chapter 1: print, input and comments Tell them you want to first build a calculator that does addition only Very simple: All they need to do is print the title: \"Addition Calculator\" print ( \"Addition Calculator\" ) Tell them they need to get the two numbers to add together from the user too. Get them thinking about using input to do this Chapter 2: Operations Show them that mathematical operations are easy to do in Python. Get them thinking about using the addition operator Chapter 3: Variables and Assignments Show that variables are a useful tool to store and manipulate values Get them to code the following: print ( \"Addition Calculator\" ) num_1 = input ( \"Enter number 1: \" ) num_2 = input ( \"Enter number 2: \" ) result = num_1 + num_2 print ( result ) This does not work properly. Tell them you'll take an aside to explain why. Chapter 4: Types Show that functions take in only certain types and return only certain types. Show them Python typecasting and where it goes wrong. Show them the concat operation too. Get them to code the following (with some \u2728aesthetic improvements\u2728): print ( \"Addition Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) result = num_1 + num_2 print ( \"The answer is \" + str ( result )) Chapter 5: Conditionals Now, we wish to extend this to the four arithmetic operations: addition, subtraction, multiplication and division. The user not only needs to specify the two numbers but also what type of operation they want to carry out. But how do you do this? We will have to code four different lines for the four different operations, but we only want the relevant line to run! #Python runs all the lines in order. The final value of result will always be num_1 divided by num_2, since it replaces the previous values in the last line result = num_1 + num_2 result = num_1 - num_2 result = num_1 * num_2 result = num_1 / num_2 This is where if statements come in. The structure of an if statement goes: if ( condition ): #These lines will only execute if condition is True So now we can write our calculator program: print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 if ( operation == \"/\" ): result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False Since the only four options are +, -, * or /, we need not check in the last if statement if operation == \"/\" . We can just assume it is \"/\", since there are no other options. print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False At this juncture, get them to test the four different operations. There should be an error when using + or -. Ask them if they know why it is not working. Tell them the reason. How to fix? elif! if ( condition_1 ): #These lines will only run if condition is True elif ( condition_2 ): #These lines will only run if condition_1 is False and condition_2 is True else : #These lines will only run if condition is False With elif, print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) Chapter 6: Loops Tell them the aim is to add the square root operation to the calculator. First, square root only accepts one argument. So get them to use existing knowledge to add this consideration. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) #result = ... else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) We will not use math.sqrt!! That function is for soulless plebs like fifth year CS students. We will go the old fashioned way: the Babylonian method. For the unfamiliar, to approximate the sqrt of n, 1. Pick a random positive number a from 0 to n exclusive. (I like n / 2) 2. Let b = n / a 3. If abs(b-a) > EPSILON, let a be the arithmetic mean of a and b (geometric mean also can but like... ew) and repeat steps 2-3 4. This converges surprisingly quickly This is also a good time to introduce them to the concept of EPSILONs. Using for loops, they should be able to code a rudimentary version which uses a fixed number of iterations. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) For the sake of \u2728knowledge\u2728, we wanna show the process as it is happening. Show them that i is a variable in and of itself and get them to print the result at each iteration. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): print ( \"Iteration \" + str ( i ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) Gasp! Why does it start from 0?? Teach them zero-index. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) We have no guarantee that the 10 iterations will be enough. Now teach them while loops and EPSILONs. Point out that a seems to always be larger than b. So a - b > EPSILON is enough. EPSILON = 0.05 print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) Chapter 7: Functions Let's add some more operations! What about absolute? Teach them how to build functions EPSILON = 0.05 def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) elif ( operation == \"abs\" ): num_1 = int ( input ( \"Enter number: \" )) result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) Chapter 8: Arrays Show them the multiple uses of arrays! 1. Simplifying the switch cases 2. Calculator memory 3. Average function EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation in single_ops ): if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number: \" )) result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) 1+2. EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] history = [] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation in single_ops ): num_1 = int ( input ( \"Enter number: \" )) if ( operation == \"sqrt\" ): a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) elif ( 'h' in operation ): if ( len ( operation ) > 1 ): index = int ( operation [ 1 :]) if ( index <= len ( history ): print ( \"The answer is \" + str ( history [ index - 1 ])) else : print ( history ) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 history . append ( result ) print ( \"The answer is \" + str ( result )) 1+2+3. EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] history = [] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) result = '' if ( operation in single_ops ): num_1 = int ( input ( \"Enter number: \" )) if ( operation == \"sqrt\" ): a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) elif ( operation == 'average' ): numbers = [] key = '' while ( key != 'q' ): key = input ( \"Type number (q to finish): \" ) if ( key != 'q' ): numbers . append ( int ( key )) result = sum ( numbers ) / len ( numbers ) print ( \"The answer is \" + str ( result )) elif ( 'h' in operation ): if ( len ( operation ) > 1 ): index = int ( operation [ 1 :]) if ( index <= len ( history ): print ( \"The answer is \" + str ( history [ index - 1 ])) else : print ( history ) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 history . append ( result ) print ( \"The answer is \" + str ( result )) Error handling: Get them to see all the places where errors can occur. Operation may not be correct Entered value may not be number sqrt may not converge (eg negative numbers)","title":"Idea for a Course Long Project (A Simple Calculator)"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#so-chapter-1-print-input-and-comments","text":"Tell them you want to first build a calculator that does addition only Very simple: All they need to do is print the title: \"Addition Calculator\" print ( \"Addition Calculator\" ) Tell them they need to get the two numbers to add together from the user too. Get them thinking about using input to do this","title":"So Chapter 1: print, input and comments"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-2-operations","text":"Show them that mathematical operations are easy to do in Python. Get them thinking about using the addition operator","title":"Chapter 2: Operations"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-3-variables-and-assignments","text":"Show that variables are a useful tool to store and manipulate values Get them to code the following: print ( \"Addition Calculator\" ) num_1 = input ( \"Enter number 1: \" ) num_2 = input ( \"Enter number 2: \" ) result = num_1 + num_2 print ( result ) This does not work properly. Tell them you'll take an aside to explain why.","title":"Chapter 3: Variables and Assignments"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-4-types","text":"Show that functions take in only certain types and return only certain types. Show them Python typecasting and where it goes wrong. Show them the concat operation too. Get them to code the following (with some \u2728aesthetic improvements\u2728): print ( \"Addition Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) result = num_1 + num_2 print ( \"The answer is \" + str ( result ))","title":"Chapter 4: Types"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-5-conditionals","text":"Now, we wish to extend this to the four arithmetic operations: addition, subtraction, multiplication and division. The user not only needs to specify the two numbers but also what type of operation they want to carry out. But how do you do this? We will have to code four different lines for the four different operations, but we only want the relevant line to run! #Python runs all the lines in order. The final value of result will always be num_1 divided by num_2, since it replaces the previous values in the last line result = num_1 + num_2 result = num_1 - num_2 result = num_1 * num_2 result = num_1 / num_2 This is where if statements come in. The structure of an if statement goes: if ( condition ): #These lines will only execute if condition is True So now we can write our calculator program: print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 if ( operation == \"/\" ): result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False Since the only four options are +, -, * or /, we need not check in the last if statement if operation == \"/\" . We can just assume it is \"/\", since there are no other options. print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 if ( operation == \"-\" ): result = num_1 - num_2 if ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) This works! But we can simplify it with the else statement : if ( condition ): #These lines will only run if condition is True else : #These lines will only run if condition is False At this juncture, get them to test the four different operations. There should be an error when using + or -. Ask them if they know why it is not working. Tell them the reason. How to fix? elif! if ( condition_1 ): #These lines will only run if condition is True elif ( condition_2 ): #These lines will only run if condition_1 is False and condition_2 is True else : #These lines will only run if condition is False With elif, print ( \"All-Purpose Calculator\" ) num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) operation = input ( \"Enter operation (+,-,*,/): \" ) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result ))","title":"Chapter 5: Conditionals"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-6-loops","text":"Tell them the aim is to add the square root operation to the calculator. First, square root only accepts one argument. So get them to use existing knowledge to add this consideration. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) #result = ... else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) We will not use math.sqrt!! That function is for soulless plebs like fifth year CS students. We will go the old fashioned way: the Babylonian method. For the unfamiliar, to approximate the sqrt of n, 1. Pick a random positive number a from 0 to n exclusive. (I like n / 2) 2. Let b = n / a 3. If abs(b-a) > EPSILON, let a be the arithmetic mean of a and b (geometric mean also can but like... ew) and repeat steps 2-3 4. This converges surprisingly quickly This is also a good time to introduce them to the concept of EPSILONs. Using for loops, they should be able to code a rudimentary version which uses a fixed number of iterations. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) For the sake of \u2728knowledge\u2728, we wanna show the process as it is happening. Show them that i is a variable in and of itself and get them to print the result at each iteration. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): print ( \"Iteration \" + str ( i ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) Gasp! Why does it start from 0?? Teach them zero-index. print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a for i in range ( 10 ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) We have no guarantee that the 10 iterations will be enough. Now teach them while loops and EPSILONs. Point out that a seems to always be larger than b. So a - b > EPSILON is enough. EPSILON = 0.05 print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result ))","title":"Chapter 6: Loops"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-7-functions","text":"Let's add some more operations! What about absolute? Teach them how to build functions EPSILON = 0.05 def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) elif ( operation == \"abs\" ): num_1 = int ( input ( \"Enter number: \" )) result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result ))","title":"Chapter 7: Functions"},{"location":"Idea-for-a-Course-Long-Project-%28A-Simple-Calculator%29/#chapter-8-arrays","text":"Show them the multiple uses of arrays! 1. Simplifying the switch cases 2. Calculator memory 3. Average function EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation in single_ops ): if ( operation == \"sqrt\" ): num_1 = int ( input ( \"Enter number: \" )) a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : num_1 = int ( input ( \"Enter number: \" )) result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 print ( \"The answer is \" + str ( result )) 1+2. EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] history = [] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) if ( operation in single_ops ): num_1 = int ( input ( \"Enter number: \" )) if ( operation == \"sqrt\" ): a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) elif ( 'h' in operation ): if ( len ( operation ) > 1 ): index = int ( operation [ 1 :]) if ( index <= len ( history ): print ( \"The answer is \" + str ( history [ index - 1 ])) else : print ( history ) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 history . append ( result ) print ( \"The answer is \" + str ( result )) 1+2+3. EPSILON = 0.05 single_ops = [ \"sqrt\" , \"abs\" ] history = [] def custom_abs ( n ): if ( n >= 0 ): return n else : return - n print ( \"All-Purpose Calculator\" ) operation = input ( \"Enter operation (+,-,*,/,sqrt,abs): \" ) result = '' if ( operation in single_ops ): num_1 = int ( input ( \"Enter number: \" )) if ( operation == \"sqrt\" ): a = num_1 / 2 b = num_1 / a while ( a - b > EPSILON ): print ( \"Iteration \" + str ( i + 1 ) + \": a = \" + str ( a ) + \", b = \" + str ( b )) a = ( a + b ) / 2 b = num_1 / a print ( \"The answer is \" + str ( a )) else : result = custom_abs ( num_1 ) print ( \"The answer is \" + str ( result )) elif ( operation == 'average' ): numbers = [] key = '' while ( key != 'q' ): key = input ( \"Type number (q to finish): \" ) if ( key != 'q' ): numbers . append ( int ( key )) result = sum ( numbers ) / len ( numbers ) print ( \"The answer is \" + str ( result )) elif ( 'h' in operation ): if ( len ( operation ) > 1 ): index = int ( operation [ 1 :]) if ( index <= len ( history ): print ( \"The answer is \" + str ( history [ index - 1 ])) else : print ( history ) else : num_1 = int ( input ( \"Enter number 1: \" )) num_2 = int ( input ( \"Enter number 2: \" )) if ( operation == \"+\" ): result = num_1 + num_2 elif ( operation == \"-\" ): result = num_1 - num_2 elif ( operation == \"*\" ): result = num_1 * num_2 else : result = num_1 / num_2 history . append ( result ) print ( \"The answer is \" + str ( result )) Error handling: Get them to see all the places where errors can occur. Operation may not be correct Entered value may not be number sqrt may not converge (eg negative numbers)","title":"Chapter 8: Arrays"},{"location":"The-Insanity-of-Python-History/","text":"[Fly, you fools, if you value sanity. There is none here.] They're gone? Alright, let's get started. What is Python? Python is derived from the Greek word, Puth\u014dn , which is the historic name of a huge serpent killed by Apollo, and it is from here that our story begins, with the trials of a certain sun god, by the name of Apollo. The Myth of Puth\u014dn Who is Puth\u014dn ? You sure you want to know? The story of its life is not for the faint of heart. If somebody said it was a happy little tale, if somebody told you it was just an average ordinary snake, not a care in the world, somebody lied. But let me assure you: This, like any story worth telling, is all about a god. That god. The god next door. Apollo. The god Puth\u014dn had hated since before he was even born. That's him. ![[Pasted image 20220111145528.png]] Yeah, that's not very inspiring, is it? Puth\u014dn was a giant serpent, sometimes weird described as a medieval-like dragon (which is definitely not the description of a serpent, mind you). Puth\u014dn was the son of Gaia, which made him Apollo's granduncle. To visualise, Puth\u014dn 's technical brother, Cronus, had a son with his sister, Rhea, who is also Puth\u014dn 's technical sister, named Zeus, who went on to impregnate the goddess and his cousin Leto with Apollo and his sister, Artemis. Puth\u014dn was actually sent by Zeus' jealous wife, Hera, who has accustomed herself to the fact that Zeus loved having affairs, but remained unwilling to let him bear life through his many polyamorous activities, to ensure that the two embryo gods were never born. He chased Leto around the lands and around the world, which is ironically made out of his mother, to ensure those kids would never see the light of day. Yes, that was pretty messed up. Leto ran and ran and ran and Zeus, who himself had become used to Hera's jealousy, decided to not even help the mother of his two new children. Yeah, you can see why Apollo hated his father. Puth\u014dn was unsuccessful in the end, and Apollo and Artemis did come out to a very destructive family. Apollo and Artemis were raised to be great warriors (and they were), and when Apollo found out all that Puth\u014dn had done to his mother, he didn't bother to consult Hera, and proceeded to Puth\u014dn 's humble abode down at the centre of the earth. Unlike the Journey to the Centre of the Earth, or any of the Jules Verne books really, Apollo's journey was relatively short, and he got to Mount Parnassus, he was beyond enraged to see the serpent happily sleeping at his home, as if without the simplest sense in the world. When the poor Puth\u014dn came to, he saw Apollo literally trying to kill him, and he decided to run. He ran and he ran and he ran until he got to the oracle of Gaia at Delphi, previously assumed to be his residence. Why he stopped, no one knows. But in the end, he did. And he proceeded to be killed. Killed until he couldn't be killed no longer. Apollo's first win, and poor Puth\u014dn 's ultimate loss. A loss so grave it could never be recuperated. And by the way, Apollo was 4 days old. 4 days . Let that sink in. Not 4 decades, not 4 years, not even 4 months old, 4 days . Yeah. That's a problem, for sure. At least he got somewhat of a win in the Trials of Apollo , but in the end, that wasn't very helpful, was it? So what was the point of this. What was the point of reading about poor Puth\u014dn and his terrible fate? Well, it all comes down... to evolution . The Trials of the Pythons Pythons were originally called nothing. Then zoologists came along, and there was \"Python\". A paralyzed French dude by the name of Fran\u00e7ois Marie Daudin named the genus as such in 1803 in one of his later volumes of Histoire naturelle, g\u00e9n\u00e9rale et particuli\u00e8re des reptiles , or for normal people, the Natural History of Reptiles. He was epic, but his choice of names were not that intelligent. Naming a snake after a villainous mythological serpent capable of destruction is one of the dumbest things I've ever heard of, but hey, at least it worked out for Fran\u00e7ois Marie Daudin, who died of tuberculosis in that year, subsequently after his wife suffered the same fate, at an age of less that 30 years old. Forget Pythagoras, this is a guy who knew he was doing. The Python is apparently stated as both a Genus and a Family. While Wikipedia insists on one page that the Genus was named after the Family, Wikipedia continues to contradict itself, by stating that they were named Pythons, the genus name, prior to their classification as Pythonidae, the family name of these serpents. While mostly being found in African or South Asian countries, Pythons continue to gain widespread attention due to them being brought and purposefully instated in the Everglades National Park in the United States, something that goes to prove that no animal can be recognised unless it's found in the United States. And that residents of the United States of America are truly dumb people, for the Pythons remain an invasive species, hated on by others, probably because they're foreigners from Burma with no passports. Monty Python and the Flying Python Unfortunately, Python didn't get its name from Puth\u014dn or the Python Snakes. That credit goes to Monty Python and the Flying Circus. Monty Python is a British comedy troupe particularly famous for such masterpieces as the Communist Game Show sketch, the Spanish Inquisition sketch and the brilliantly named Camelot song. They excel in taking humour from absurdity, and their comedy is often described as silly and illogical. Nonetheless, they were all the rage back in the 80s. Monty Python caused quite a stir in 1979 due to their film \"Monty Python and the Life of Brian\", which retold the coming of the Messiah in a series of fast-paced comedy sketches. The film is also the origin of their most well-known song: \"Always Look on the Bright Side of Life\", which was even played at the London Olympics in 2012 by Monty Python legend Eric Idle to thunderous applause and singalong.","title":"The Insanity of Python History"},{"location":"The-Insanity-of-Python-History/#fly-you-fools-if-you-value-sanity-there-is-none-here","text":"They're gone? Alright, let's get started. What is Python? Python is derived from the Greek word, Puth\u014dn , which is the historic name of a huge serpent killed by Apollo, and it is from here that our story begins, with the trials of a certain sun god, by the name of Apollo.","title":"[Fly, you fools, if you value sanity. There is none here.]"},{"location":"The-Insanity-of-Python-History/#the-myth-of-puthon","text":"Who is Puth\u014dn ? You sure you want to know? The story of its life is not for the faint of heart. If somebody said it was a happy little tale, if somebody told you it was just an average ordinary snake, not a care in the world, somebody lied. But let me assure you: This, like any story worth telling, is all about a god. That god. The god next door. Apollo. The god Puth\u014dn had hated since before he was even born. That's him. ![[Pasted image 20220111145528.png]] Yeah, that's not very inspiring, is it? Puth\u014dn was a giant serpent, sometimes weird described as a medieval-like dragon (which is definitely not the description of a serpent, mind you). Puth\u014dn was the son of Gaia, which made him Apollo's granduncle. To visualise, Puth\u014dn 's technical brother, Cronus, had a son with his sister, Rhea, who is also Puth\u014dn 's technical sister, named Zeus, who went on to impregnate the goddess and his cousin Leto with Apollo and his sister, Artemis. Puth\u014dn was actually sent by Zeus' jealous wife, Hera, who has accustomed herself to the fact that Zeus loved having affairs, but remained unwilling to let him bear life through his many polyamorous activities, to ensure that the two embryo gods were never born. He chased Leto around the lands and around the world, which is ironically made out of his mother, to ensure those kids would never see the light of day. Yes, that was pretty messed up. Leto ran and ran and ran and Zeus, who himself had become used to Hera's jealousy, decided to not even help the mother of his two new children. Yeah, you can see why Apollo hated his father. Puth\u014dn was unsuccessful in the end, and Apollo and Artemis did come out to a very destructive family. Apollo and Artemis were raised to be great warriors (and they were), and when Apollo found out all that Puth\u014dn had done to his mother, he didn't bother to consult Hera, and proceeded to Puth\u014dn 's humble abode down at the centre of the earth. Unlike the Journey to the Centre of the Earth, or any of the Jules Verne books really, Apollo's journey was relatively short, and he got to Mount Parnassus, he was beyond enraged to see the serpent happily sleeping at his home, as if without the simplest sense in the world. When the poor Puth\u014dn came to, he saw Apollo literally trying to kill him, and he decided to run. He ran and he ran and he ran until he got to the oracle of Gaia at Delphi, previously assumed to be his residence. Why he stopped, no one knows. But in the end, he did. And he proceeded to be killed. Killed until he couldn't be killed no longer. Apollo's first win, and poor Puth\u014dn 's ultimate loss. A loss so grave it could never be recuperated. And by the way, Apollo was 4 days old. 4 days . Let that sink in. Not 4 decades, not 4 years, not even 4 months old, 4 days . Yeah. That's a problem, for sure. At least he got somewhat of a win in the Trials of Apollo , but in the end, that wasn't very helpful, was it? So what was the point of this. What was the point of reading about poor Puth\u014dn and his terrible fate? Well, it all comes down... to evolution .","title":"The Myth of Puth\u014dn"},{"location":"The-Insanity-of-Python-History/#the-trials-of-the-pythons","text":"Pythons were originally called nothing. Then zoologists came along, and there was \"Python\". A paralyzed French dude by the name of Fran\u00e7ois Marie Daudin named the genus as such in 1803 in one of his later volumes of Histoire naturelle, g\u00e9n\u00e9rale et particuli\u00e8re des reptiles , or for normal people, the Natural History of Reptiles. He was epic, but his choice of names were not that intelligent. Naming a snake after a villainous mythological serpent capable of destruction is one of the dumbest things I've ever heard of, but hey, at least it worked out for Fran\u00e7ois Marie Daudin, who died of tuberculosis in that year, subsequently after his wife suffered the same fate, at an age of less that 30 years old. Forget Pythagoras, this is a guy who knew he was doing. The Python is apparently stated as both a Genus and a Family. While Wikipedia insists on one page that the Genus was named after the Family, Wikipedia continues to contradict itself, by stating that they were named Pythons, the genus name, prior to their classification as Pythonidae, the family name of these serpents. While mostly being found in African or South Asian countries, Pythons continue to gain widespread attention due to them being brought and purposefully instated in the Everglades National Park in the United States, something that goes to prove that no animal can be recognised unless it's found in the United States. And that residents of the United States of America are truly dumb people, for the Pythons remain an invasive species, hated on by others, probably because they're foreigners from Burma with no passports.","title":"The Trials of the Pythons"},{"location":"The-Insanity-of-Python-History/#monty-python-and-the-flying-python","text":"Unfortunately, Python didn't get its name from Puth\u014dn or the Python Snakes. That credit goes to Monty Python and the Flying Circus. Monty Python is a British comedy troupe particularly famous for such masterpieces as the Communist Game Show sketch, the Spanish Inquisition sketch and the brilliantly named Camelot song. They excel in taking humour from absurdity, and their comedy is often described as silly and illogical. Nonetheless, they were all the rage back in the 80s. Monty Python caused quite a stir in 1979 due to their film \"Monty Python and the Life of Brian\", which retold the coming of the Messiah in a series of fast-paced comedy sketches. The film is also the origin of their most well-known song: \"Always Look on the Bright Side of Life\", which was even played at the London Olympics in 2012 by Monty Python legend Eric Idle to thunderous applause and singalong.","title":"Monty Python and the Flying Python"},{"location":"_Footer/","text":"By a team of students from NUS High School, aiming to make coding easier for everyone.","title":" Footer"}]}